<html>
<head>
<!--
Plans:
MP fail correctly +
Undo +
Negation +
Axiom clicks +
UI +
Record proofs +
Better varnames in output +
Store types of connective outputs +
Sets +
Equality +
Fix bug involving renumbering ax10 +
Containment +
Save theorems +
Distinct variable conditions +
Definitions +
Set theory +
Import theorems from axiom string
Classes
Release
-->
<script type="text/javascript">
//scope=local/global
//quant=universal/existential
wff={type:"const",op:"->",0:{type:"var",scope:"l",quant:"u",id:0},1:{type:"var",scope:"g",quant:"e",id:0}}
//connective argument types
connectives={"->":{in:["wff","wff"],out:"wff"},"~":{in:["wff"],out:"wff"},"<->":{in:["wff","wff"],out:"wff"},"&":{in:["wff","wff"],out:"wff"},"|":{in:["wff","wff"],out:"wff"},"A.":{in:["set","wff"],out:"wff"},"E.":{in:["set","wff"],out:"wff"},"F.":{in:["set","wff"],out:"wff"},"=":{in:["set","set"],out:"wff"},"<":{in:["set","set"],out:"wff"},"sub":{in:["set","set","wff"],out:"wff"}}
function termeq(x,y){
	if(x.type!=y.type){
		return false
	}else{
		if(x.type=="const"){
			if(x.op!=y.op){
				return false
			}else{
				for(var i=0;i<connectives[x.op].in.length;i++){
					if(!termeq(x[i],y[i])){
						return false
					}
				}
				return true
			}
		}else{
			if(x.scope==y.scope&&x.quant==y.quant&&x.sort==y.sort&&x.id==y.id){
				return true
			}else{
				return false
			}
		}
	}
}
function occurs(v,exp){
	if(exp.type=="var"){
		return (exp.scope==v.scope&&exp.quant==v.quant&&exp.sort==v.sort&&exp.id==v.id)
	}else{
		for(var i=0;i<connectives[exp.op].in.length;i++){
			if(occurs(exp[i],v)){
				return true
			}
		}
		return false
	}
}
function subst(exp,a,b){
	if(exp.type=="var"){
		if(termeq(exp,a)){
			return b
		}else{
			return exp
		}
	}else{
		var texp=Object.assign({},exp)
		for(var i=0;i<connectives[exp.op].in.length;i++){
			texp[i]=subst(exp[i],a,b)
		}
		return texp
	}
}
function vars(exp){
	if(exp.type=="var"){
		return [exp]
	}else{
		var t=[]
		for(var i=0;i<connectives[exp.op].in.length;i++){
			var o=vars(exp[i])
			for(var j=0;j<o.length;j++){
				if(t.every(a=>!termeq(a,o[j]))){
					t.push(o[j])
				}
			}
		}
		return t
	}
}
function unify(eq,dv){
	var eq2=Object.assign([],eq)
	var out=[]
	var cont=true
	while(eq2.length>0){
		for(var i=0;i<eq2.length;i++){
			var l=eq2[i][0]
			var r=eq2[i][1]
			if(termeq(l,r)){ //delete
				eq2.splice(i,1)
				cont=true
			}else if(l.type=="const"&&r.type=="const"){
				if(l.op==r.op){ //decompose
					eq2.splice(i,1)
					cont=true
					for(var j=0;j<connectives[l.op].in.length;j++){
						eq2.push([l[j],r[j]])
					}
				}else{ //conflict
					return false
				}
			}else if(l.type=="const"&&r.type=="var"){ //swap
				eq2[i]=[r,l]
				cont=true
			}else if(occurs(l,r)){ //check
				return false
			}else{ //eliminate
				cont=true
				var temp=eq2.splice(i,1)
				for(var j=0;j<eq2.length;j++){
					for(var k=0;k<2;k++){
						eq2[j][k]=subst(eq2[j][k],l,r)
					}
				}
				for(j=0;j<out.length;j++){
					for(var k=0;k<2;k++){
						out[j][k]=subst(out[j][k],l,r)
					}
				}
				out.push(temp[0])
			}
		}
	}
	var dv2=Object.assign([],dv)
	for(var i=0;i<out.length;i++){
		var tvars=vars(out[i][1])
		var dv3=[]
		for(var j=0;j<dv2.length;j++){
			var ind=dv2[j].find(a=>termeq(a,out[i][0]))
			if(ind>-1){
				for(var k=0;k<tvars.length;k++){
					var t=Object.assign({},dv2[j])
					t[ind]=tvars[k]
					if(termeq(t[0],t[1])){ //todo: generalize to larger groups
						return false
					}
					dv3.push(t)
				}
			}else{
				dv3.push(dv2[j])
			}
		}
		dv2=dv3
	}
	return {eq:out,dv:dv2}
}
function renumber(exp,afters,lb,gb){
	var afters2=Object.assign({},afters);
	if(exp.type=="var"){
		if(exp.scope=="l"){
			var lb2;
			if(Object.keys(lb).includes([exp.sort,exp.id]+"")){
				lb2=lb
			}else{
				lb2=Object.assign({},lb)
				if(!afters2[exp.sort]){
					afters2[exp.sort]=0
				}
				lb2[[exp.sort,exp.id]]=afters2[exp.sort]
				afters2[exp.sort]++
			}
			return {exp:{type:"var",scope:"l",quant:exp.quant,sort:exp.sort,id:lb2[[exp.sort,exp.id]]},afters:afters2,lb:lb2,gb:gb}
		}else{
			var gb2;
			if(Object.keys(gb).includes([exp.sort,exp.id]+"")){
				gb2=gb
			}else{
				gb2=Object.assign({},gb)
				if(!afters2[exp.sort]){
					afters2[exp.sort]=0
				}
				gb2[[exp.sort,exp.id]]=afters2[exp.sort]
				afters2[exp.sort]++
			}
			return {exp:{type:"var",scope:"g",quant:exp.quant,sort:exp.sort,id:gb[[exp.sort,exp.id]]},afters:afters2,lb:lb,gb:gb2}
		}
	}else{
		var exp2=Object.assign({},exp)
		var lb2=lb
		var gb2=gb
		for(var i=0;i<connectives[exp.op].in.length;i++){
			var t=renumber(exp[i],afters2,lb2,gb2)
			afters2=t.afters
			lb2=t.lb
			gb2=t.gb
			exp2[i]=t.exp
		}
		return {exp:exp2,afters:afters2,lb:lb2,gb:gb2}
	}
}
//converts postfix into formula format
function parseaxiom(axl){
	var tstack=[]
	for(var i=0;i<axl.length;i++){
		if(typeof axl[i]=="number"){
			tstack.push(parsevar(axl[i],"wff"))
		}else{
			var texp={type:"const",op:axl[i],sort:"wff"}
			for(var j=0;j<connectives[axl[i]].in.length;j++){
				texp[j]=tstack.pop()
				texp[j].sort=connectives[axl[i]].in[j] //hack to autocast variables
			}
			tstack.push(texp)
		}
	}
	return tstack.pop()
}
function parsevar(id,sort){
	return {type:"var",scope:"l",quant:"u",sort:sort,id:id}
}
function parsedv(dvl){
	var t=[]
	for(var i=0;i<dvl.length;i++){
		t.push([parsevar(dvl[i][0][1],dvl[i][0][0]),parsevar(dvl[i][1][1],dvl[i][1][0])]) //todo: generalize to larger groups
	}
	return t
}
function pushaxiom(ax,dv,name){
	stack.push({formula:ax,proof:{name:name,args:[]},dv:dv})
	undostack.push({action:"ax",axiom:ax})
}
//should probably be replaced with more general inference application
function mp(){
	renumberstack()
	if(stack.length<2){
		return
	}
	var maj=stack.pop()
	var min=stack.pop()
	var uni=unify([[maj.formula,{type:"const",op:"->",sort:"wff",0:min.formula,1:{type:"var",scope:"l",quant:"u",sort:"wff",id:-1}}]],min.dv.concat(maj.dv))
	if(uni){
		undostack.push({action:"mp",min:min,maj:maj})
		var dv2=uni.dv
		var form;
		for(var i=0;i<uni.eq.length;i++){
			if(uni.eq[i][0].id==-1){
				form=uni.eq[i][1]
			}else if(uni.eq[i][1].id==-1){
				form=uni.eq[i][0]
			}
		}
		for(var i=0;i<dv2.length;i++){
			if(!dv2[i].some(a=>vars(form).some(b=>termeq(a,b)))){
				dv2.splice(i,1)
			}
		}
		stack.push({formula:form,proof:{name:"ax-mp",args:[min,maj]},dv:dv2})
	}else{
		stack.push(min)
		stack.push(maj)
	}
}
function gen(){
	renumberstack()
	if(stack.length<1){
		return
	}
	var hyp=stack.pop()
	stack.push({formula:{type:"const",op:"A.",sort:"wff",0:{type:"var",scope:"l",quant:"u",sort:"set",id:-1},1:hyp.formula},proof:{name:"ax-gen",args:[hyp]},dv:hyp.dv})
	undostack.push({action:"gen",hyp:hyp})
}
function undo(){
	var undone=undostack.pop()
	if(undone.action=="mp"){
		stack.pop()
		stack.push(undone.min)
		stack.push(undone.maj)
	}else if(undone.action=="ax"){
		stack.pop()
	}else if(undone.action=="delete"){
		stack.push(undone.top)
	}else if(undone.action=="swap"){
		swaptos()
		undostack.pop()
	}else if(undone.action=="gen"){
		stack.pop()
		stack.push(undone.hyp)
	}else if(undone.action=="thm"){
		stack.pop()
	}
}
function deletetos(){
	var t=stack.pop()
	undostack.push({action:"delete",top:t})
}
function swaptos(){
	var t=stack.pop()
	var s=stack.pop()
	stack.push(t)
	stack.push(s)
	undostack.push({action:"swap"})
}
display={"->":["(",0,"->",1,")"],"~":["~",0],"<->":["(",0,"<->",1,")"],"&":["(",0,"/\\",1,")"],"|":["(",0,"\\/",1,")"],"A.":["A",0,1],"E.":["E",0,1],"F.":["NF",0,1],"=":[0,"=",1],"<":[0,"&lt;",1],"sub":["[",0,"/",1,"]",2]}
function print(exp){
	if(exp.type=="var"){
		if(exp.sort=="wff"){
			const varnames="PQRSTUVWXYZ"
			if(exp.id<11){
				return varnames[exp.id]
			}else{
				return varnames[exp.id%11]+""+(Math.floor(exp.id/11)-1)
			}
		}else if(exp.sort=="set"){
			const varnames="xyzwvutsrqp"
			if(exp.id<11){
				return varnames[exp.id]
			}else{
				return varnames[exp.id%11]+""+(Math.floor(exp.id/11)-1)
			}
		}
		return exp.sort+exp.id
	}else{
		var t=""
		for(var i=0;i<display[exp.op].length;i++){
			if(typeof display[exp.op][i]=="number"){
				t+=print(exp[display[exp.op][i]])
			}else{
				t+=display[exp.op][i]
			}
		}
		return t
	}
}
function printdv(thm){
	if(thm.dv.length==0){
		return print(thm.formula)
	}
	var t=print(thm.formula)+" dvs: "
	for(var i=0;i<thm.dv.length;i++){
		t+=print(thm.dv[i][0])+","+print(thm.dv[i][1])+" " //todo: generalize to larger groups
	}
	return t
}
function showproof(proof){
	var t=""
	for(var i=0;i<proof.args.length;i++){
		t+=showproof(proof.args[i].proof)
		t+=" "
	}
	return t+proof.name
}
function dvcopy(dv){
	out=[]
	for(var i=0;i<dv.length;i++){
		var t=[]
		for(var j=0;j<dv[i].length;j++){
			t.push(deepcopy(dv[i][j]))
		}
		out.push(t)
	}
	return out
}
function deepcopy(x){
	if(x.proof){
		return {formula:deepcopy(x.formula),proof:deepcopy(x.proof),dv:dvcopy(x.dv)}
	}else if(!x){
		return null
	}else if(x.type=="var"){
		return Object.assign({},x)
	}else if(x.name){
		var t=Object.assign({},x)
		for(var i=0;i<t.args.length;i++){
			t.args[i]=deepcopy(t.args[i])
		}
		return t
	}else{
		var t=Object.assign({},x)
		for(var i=0;i<connectives[t.op].in.length;i++){
			t[i]=deepcopy(t[i])
		}
		return t
	}
}
function savethm(){
	var t=stack[stack.length-1]
	saved[prompt("Name")]=deepcopy(t)
}
function loadthm(){
	var t=prompt("Name")
	stack.push(saved[t])
	undostack.push({action:"thm",name:t})
}
stack=[]
undostack=[]
saved={}
function dvreplace(dv,a,b){
	if(dv.length){
		var t=[]
		for(var i=0;i<dv.length;i++){
			t.push(dvreplace(dv[i],a,b))
		}
		return t
	}else{
		if([dv.sort,dv.id]+""==a){
			return Object.assign(Object.assign({},dv),{id:b})
		}else{
			return dv
		}
	}
}
function renumberstack(){
	var afters=0;
	var gb={};
	for(var i=stack.length-1;i>=0;i--){
		var t=renumber(stack[i].formula,afters,{},gb)
		stack[i].formula=t.exp
		afters=t.afters
		gb=t.gb
		for(var j=Object.keys(t.lb).length-1;j>=0;j--){
			stack[i].dv=dvreplace(stack[i].dv,Object.keys(t.lb)[j],t.lb[Object.keys(t.lb)[j]])
		}
	}
}
function renderstack(sep){
	renumberstack()
	var ret=stack.reverse().map(a=>printdv(a)).join(sep)
	stack.reverse()
	return ret
}
function showstack(){
	stackbox.innerHTML=renderstack("<br>")
}
//test script for b1/2 features, might not work anymore
function test(){
	//test wff 1 is (P->R) test wff 2 is (P->Q)
	console.log(unify([[
		{type:"const",op:"->",sort:"wff",0:{type:"var",scope:"l",quant:"u",sort:"wff",id:0},1:{type:"var",scope:"l",quant:"u",sort:"wff",id:2}},
		{type:"const",op:"->",sort:"wff",0:{type:"var",scope:"l",quant:"u",sort:"wff",id:0},1:{type:"var",scope:"l",quant:"u",sort:"wff",id:1}}]]))
	console.log(renumber(
		{type:"const",op:"->",sort:"wff",0:{type:"var",scope:"l",quant:"u",sort:"wff",id:0},1:{type:"var",scope:"l",quant:"u",sort:"wff",id:2}}
		,0,{},{}))
	console.log(print(
		{type:"const",op:"->",sort:"wff",0:{type:"var",scope:"l",quant:"u",sort:"wff",id:0},1:{type:"var",scope:"l",quant:"u",sort:"wff",id:2}}
		,0,{},{}))
	stack.push(
		{type:"const",op:"->",sort:"wff",0:{type:"var",scope:"l",quant:"u",sort:"wff",id:0},1:{type:"var",scope:"l",quant:"u",sort:"wff",id:2}}
		)
	stack.push(
		{type:"const",op:"->",sort:"wff",0:{type:"var",scope:"l",quant:"u",sort:"wff",id:2},1:{type:"const",op:"->",sort:"wff",0:{type:"var",scope:"l",quant:"u",sort:"wff",id:0},1:{type:"var",scope:"l",quant:"u",sort:"wff",id:2}}}
		)
	console.log(renderstack())
	mp()
	console.log(renderstack())
}
</script>
</head>
<body>
Metamath Solitaire JS (build 4.1, May 30)
<br>
<button onclick="pushaxiom(parseaxiom([0,1,'->',0,'->']),[],'ax-1');showstack()">ax1</button>
<button onclick="pushaxiom(parseaxiom([2,0,'->',1,0,'->','->',2,1,'->',0,'->','->']),[],'ax-2');showstack()">ax2</button>
<button onclick="pushaxiom(parseaxiom([0,1,'->',1,'~',0,'~','->','->']),[],'ax-3');showstack()">ax3</button>
<button onclick="mp();showstack()">axmp</button>
<button onclick="pushaxiom(parseaxiom([1,0,'->',1,0,'<->','->']),[],'df-bi1');showstack()">dfbi1</button>
<button onclick="pushaxiom(parseaxiom([0,1,'->',1,0,'<->','->']),[],'df-bi2');showstack()">dfbi2</button>
<button onclick="pushaxiom(parseaxiom([1,0,'<->',0,1,'->','->',1,0,'->','->']),[],'df-bi3');showstack()">dfbi3</button>
<button onclick="pushaxiom(parseaxiom([1,0,'~','->',1,0,'|','<->']),[],'df-or');showstack()">dfor</button>
<button onclick="pushaxiom(parseaxiom([1,'~',0,'->','~',1,0,'&','<->']),[],'df-an');showstack()">dfan</button>
<br>
<button onclick="pushaxiom(parseaxiom([0,0,0,'A.','->']),[],'ax-4');showstack()">ax4</button>
<button onclick="pushaxiom(parseaxiom([1,0,'A.',0,0,'A.','->',1,0,0,'A.','->',0,'A.','->']),[],'ax-5');showstack()">ax5</button>
<button onclick="pushaxiom(parseaxiom([0,0,'A.','~',0,'A.',0,0,'A.','~','->']),[],'ax-6');showstack()">ax6</button>
<button onclick="pushaxiom(parseaxiom([0,1,'A.',0,'A.',0,0,'A.',1,'A.','->']),[],'ax-7');showstack()">ax7</button>
<button onclick="gen();showstack()">axgen</button>
<button onclick="pushaxiom(parseaxiom([0,'~',0,'A.','~',0,0,'E.','<->']),[],'df-ex');showstack()">dfex</button>
<button onclick="pushaxiom(parseaxiom([0,0,'A.',0,'->',0,'A.',0,0,'F.','<->']),[],'df-nf');showstack()">dfnf</button>
<br>
<button onclick="pushaxiom(parseaxiom([2,1,'=',2,0,'=','->',1,0,'=','->']),[],'ax-8');showstack()">ax8</button>
<button onclick="pushaxiom(parseaxiom([0,0,0,'A.',1,0,'=','->',0,'A.','->']),[],'ax-9');showstack()">ax9</button>
<button onclick="pushaxiom(parseaxiom([0,1,'A.',0,0,'A.','->',1,0,'=',0,'A.','->']),[],'ax-10');showstack()">ax10</button>
<button onclick="pushaxiom(parseaxiom([0,1,0,'=','->',0,'A.',0,'->',1,0,'=','->',1,0,'=',0,'A.','~','->']),[],'ax-11');showstack()">ax11</button>
<button onclick="pushaxiom(parseaxiom([2,1,'=',0,'A.',2,1,'=','->',2,0,'=',0,'A.','~','->',1,0,'=',0,'A.','~','->']),[],'ax-12');showstack()">ax12</button>
<button onclick="pushaxiom(parseaxiom([2,1,'<',2,0,'<','->',1,0,'=','->']),[],'ax-13');showstack()">ax13</button>
<button onclick="pushaxiom(parseaxiom([1,2,'<',0,2,'<','->',1,0,'=','->']),[],'ax-14');showstack()">ax14</button>
<button onclick="pushaxiom(parseaxiom([0,0,'A.',0,'->',1,0,'=',0,'A.','->']),parsedv([[['set',0],['set',1]]]),'ax-15');showstack()">ax15</button>
<button onclick="pushaxiom(parseaxiom([0,0,'A.',0,'->']),parsedv([[['wff',0],['set',0]]]),'ax-16');showstack()">ax16</button>
<button onclick="pushaxiom(parseaxiom([0,0,1,'=','&',1,'E.',0,0,1,'=','->','&',0,1,0,'sub','<->']),[],'df-sub');showstack()">dfsub</button>
<br>
<button onclick="pushaxiom(parseaxiom([2,1,'=',2,0,'<',1,0,'<','<->',0,'A.','->']),parsedv([[['set',0],['set',1]],[['set',0],['set',2]]]),'ax-ext');showstack()">axext</button>
<button onclick="pushaxiom(parseaxiom([0,1,0,'<','&',0,'E.',0,2,'<','<->',2,'A.',1,2,'=',0,'->',2,'A.',1,'E.','->',0,'E.']),parsedv([[['set',0],['set',1]],[['set',0],['set',2]],[['set',1],['set',2]],[['set',1],['wff',1]]]),'ax-rep');showstack()">axrep</button>
<button onclick="pushaxiom(parseaxiom([0,1,'<',2,0,'<',0,1,'<','&',0,'E.','->',1,'A.',0,'E.']),parsedv([[['set',0],['set',1]],[['set',0],['set',2]],[['set',1],['set',2]]]),'ax-un');showstack()">axun</button>
<button onclick="pushaxiom(parseaxiom([0,1,'<',2,0,'<',1,0,'<','->',0,'A.','->',1,'A.',0,'E.']),parsedv([[['set',0],['set',1]],[['set',0],['set',2]],[['set',1],['set',2]]]),'ax-pow');showstack()">axpow</button>
<button onclick="pushaxiom(parseaxiom([1,2,'<','~',0,2,'<','->',2,'A.',1,0,'<','&',0,'E.',1,0,'<','->']),parsedv([[['set',0],['set',1]],[['set',0],['set',2]],[['set',1],['set',2]]]),'ax-reg');showstack()">axreg</button>
<button onclick="pushaxiom(parseaxiom([0,2,'<',2,1,'<','&',2,'E.',0,1,'<','->',1,'A.',0,1,'<','&',0,'E.']),parsedv([[['set',0],['set',1]],[['set',0],['set',2]],[['set',1],['set',2]]]),'ax-inf');showstack()">axinf</button>
<br>
<button onclick="undo();showstack()">undo</button>
<button onclick="deletetos();showstack()">delete top</button>
<button onclick="swaptos();showstack()">swap top</button>
<button onclick="console.log(showproof(stack[stack.length-1].proof))">show proof</button>
<button onclick="savethm()">save top</button>
<button onclick="loadthm();showstack()">load</button>
<div id="stackbox"></div>
</body>
</html>
